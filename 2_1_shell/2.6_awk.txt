awk
	-F fs
	--field-separator fs
    Use fs for the input field separator (the value of  the  FS  predefined  variable)
	
需要注意的问题
#####-F 指定的如果不是特殊字符，那么可以不加单引号或者是双引号，
#####但是后面的{print $1, ... $n}，这里就是必须要使用单引号了。
[root@CH ~]# awk -F  :  "{print $1}" 1.txt  # 这个就是不正确的。
root:x:0:0:root:/root:/bin/bash
bin:x:1:1:bin:/bin:/sbin/nologin
daemon:x:2:2:daemon:/sbin:/sbin/nologin
... ...
postfix:x:89:89::/var/spool/postfix:/sbin/nologin
sshd:x:74:74:Privilege-separated SSH:/var/empty/sshd:/sbin/nologin
fd:x:500:500::/home/fd:/bin/bash
#####二下面的就得到正确的结果了。
[root@CH ~]# awk -F  ":"  '{print $1}' 1.txt
root
bin
daemon
adm
... ...
sshd
fd
[root@CH ~]# awk -F   ':'  '{print $1}' 1.txt
root
bin
daemon
adm
... ...
sshd
fd
[root@CH ~]# awk -F   :  '{print $1}' 1.txt
root
bin
daemon
adm
... ...
sshd
fd
#####注意下面两个的区别，有没有加逗号的差别
[root@CH ~]# awk -F ":" '{print $1 $3 $5}' 1.txt
root0root
[root@CH ~]# awk -F ":" '{print $1,$3,$5}' 1.txt
root 0 root
#####输出指定分隔符，需要使用OFS="分隔符" OutputFiledSeparator，我猜测是这个意思。
#####OFS         The output field separator, a space by default.
[root@CH ~]# awk -F ":" 'OFS="___" {print $1,$3,$5}' 1.txt
root___0___root
bin___1___bin
daemon___2___daemon
adm___3___adm
lp___4___lp
sync___5___sync
shutdown___6___shutdown
halt___7___halt
mail___8___mail
uucp___10___uucp
operator___11___operator

####awk的匹配功能
[root@CH ~]# awk '/root/' 1.txt
root:x:0:0:root:/root:/bin/bash
operator:x:11:0:operator:/root:/sbin/nologin
#####匹配多个
[root@CH ~]# awk '/root|fd|sshd/' 1.txt
root:x:0:0:root:/root:/bin/bash
operator:x:11:0:operator:/root:/sbin/nologin
sshd:x:74:74:Privilege-separated SSH:/var/empty/sshd:/sbin/nologin
fd:x:500:500::/home/fd:/bin/bash
[root@CH ~]#
####通配符的使用，比sed, grep更方便一点。grep -E, sed -r
[root@CH ~]# awk '/r*t/' 1.txt #0个或者多个r
root:x:0:0:root:/root:/bin/bash
shutdown:x:6:0:shutdown:/sbin:/sbin/shutdown
... ...
sshd:x:74:74:Privilege-separated SSH:/var/empty/sshd:/sbin/nologin
[root@CH ~]# awk '/r?t/' 1.txt #0个或者1个r
root:x:0:0:root:/root:/bin/bash
... ...
sshd:x:74:74:Privilege-separated SSH:/var/empty/sshd:/sbin/nologin
[root@CH ~]# awk '/r+t/' 1.txt #一个或者多个r
vcsa:x:69:69:virtual console memory owner:/dev:/sbin/nologin
[root@CH ~]# awk '/r+o/' 1.txt #同上
root:x:0:0:root:/root:/bin/bash
operator:x:11:0:operator:/root:/sbin/nologin
####也可以把多个字符当作一个整体来匹配
[root@CH ~]# awk '/(oo)+/' 1.txt
root:x:0:0:root:/root:/bin/bash
lp:x:4:7:lp:/var/spool/lpd:/sbin/nologin
mail:x:8:12:mail:/var/spool/mail:/sbin/nologin
uucp:x:10:14:uucp:/var/spool/uucp:/sbin/nologin
operator:x:11:0:operator:/root:/sbin/nologin
nobooooooooooooooooooody:x:99:99:Nobody:/:/sbin/nologin
postfix:x:89:89::/var/spool/postfix:/sbin/nologin
[root@CH ~]#
####grep的使用方式
[root@CH ~]# grep -E '(oo){2,4}' 1.txt
noboooooooody:x:99:99:Nobody:/:/sbin/nologin
[root@CH ~]# grep -E '(oo){2,5}' 1.txt
noboooooooody:x:99:99:Nobody:/:/sbin/nologin
[root@CH ~]# grep -E '(oo){2,}' 1.txt
noboooooooody:x:99:99:Nobody:/:/sbin/nologin
[root@CH ~]# grep -E '(oo){3,}' 1.txt
noboooooooody:x:99:99:Nobody:/:/sbin/nologin
[root@CH ~]# grep -E '(oo){4,}' 1.txt
noboooooooody:x:99:99:Nobody:/:/sbin/nologin
[root@CH ~]# grep -E '(oo){5,}' 1.txt
####sed的使用权方式
[root@CH ~]# sed  -rn '/(oo){5,}/p' 1.txt
[root@CH ~]# sed  -rn '/(oo){2,}/p' 1.txt
noboooooooody:x:99:99:Nobody:/:/sbin/nologin
[root@CH ~]# sed  -rn '/(oo){2,4}/p' 1.txt
noboooooooody:x:99:99:Nobody:/:/sbin/nologin
[root@CH ~]# sed  -rn '/(oo){4}/p' 1.txt
noboooooooody:x:99:99:Nobody:/:/sbin/nologin
[root@CH ~]# sed  -rn '/(oo){3}/p' 1.txt
noboooooooody:x:99:99:Nobody:/:/sbin/nologin
[root@CH ~]# sed  -rn '/(oo){5}/p' 1.txt
[root@CH ~]#
####只匹配指定的段
[root@CH ~]# awk -F ':' '$1~/f*d/' 1.txt
daemon:x:2:2:daemon:/sbin:/sbin/nologin
adm:x:3:4:adm:/var/adm:/sbin/nologin
shutdown:x:6:0:shutdown:/sbin:/sbin/shutdown
nobody:x:99:99:Nobody:/:/sbin/nologin
noboooooooody:x:99:99:Nobody:/:/sbin/nologin
sshd:x:74:74:Privilege-separated SSH:/var/empty/sshd:/sbin/nologin
fd:x:500:500::/home/fd:/bin/bash
####根据匹配指定的段的结果，只输出指定的字段，可以参考上面的结果，如最后一行的500正好是fd的uid，也就是第3个字段。
[root@CH ~]# awk -F ':' '$1~/f*d/ {print $3}' 1.txt
2
3
6
99
99
74
500
#######################################################
[root@CH ~]# awk -F ':' '$1~/f*d/ {print $1,$3}; $1~/r*o/ {print $1,$3}' 1.txt
root 0
daemon 2
daemon 2
adm 3
shutdown 6
shutdown 6
operator 11
gopher 13
nobody 99
nobody 99
noboooooooody 99
noboooooooody 99
postfix 89
sshd 74
fd 500
####注意下面的匹配结果，和第一个过滤条件没有关系
[root@CH ~]# awk -F ':' '$1~/f*d/ {print $1,$3}; $1~/s*h/ {print $1,$3}' 1.txt
daemon 2
adm 3
shutdown 6
shutdown 6
halt 7
gopher 13
nobody 99
noboooooooody 99
saslauth 499
sshd 74
sshd 74
fd 500

###############################################################################
确实是因为想让awk支持\{\}，得在awk命令行中加入--posix参数.
gawk --posix -F ':' '$1~/(oo)+|y{1,2}/' passwd
root:x:0:0:root:/root:/bin/bash
nobody:x:65534:65533:nobody:/var/lib/nobody:/bin/bash
yanwh:x:1002:1000::/home/yanwh:/bin/bash

回复 删除收藏
aming

很对
lihongwei

（oo）+不是匹配偶数么？怎么nobody也会有，我自己试着添加了tom，oaoa，这俩个就匹配不到
aming

或者y{1,2}

[root@CH ~]# awk --posix -F ':' '/(oo){2,4}/' 1.txt
noboooooooody:x:99:99:Nobody:/:/sbin/nologin
[root@CH ~]#
###############################################################################







